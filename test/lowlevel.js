"use strict";
var assert = require('assert');

var texvcjs = require('../');
var ast = texvcjs.ast;

// This is the "low-level" example from the README.
// It defines a `contains_func` visitor function which tests for a
// specific TeX function in the input string.
describe('Low-level API', function() {

    ast.RenderT.TEX_ONLY.prototype.tex_contains = function(target) {
        var t = this.tex_part();
        // may have trailing '(', '[', '\\{' or " "
        t = t.replace(/(\(|\[|\\{| )$/, '');
        // special case #1: \\operatorname {\\somefunc}
        if (/^\\operatorname \{/.test(t)) {
            return target === '\\operatorname' ||
                t === ('\\operatorname {'+target+'}');
        }
        // special case #2: \\mbox{\\somefunc}
        if (/^\\mbox\{/.test(t)) {
            return target === '\\mbox' ||
                t === ('\\mbox{'+target+'}');
        }
        // special case #3: \\color, \\pagecolor, \\definecolor
        if (/^\\(color|pagecolor|definecolor) /.test(t)) {
            return t.slice(0, target.length+1) === (target + ' ');
        }
        return t === target;
    };
    // This is a function of one argument, which becomes the first argument
    // in the visitor functions.  The subsequent arguments are the fields of
    // that particular AST class.
    ast.Tex.defineVisitor("contains_func", {
        FQ: function(target, base, down, up) {
            // base_down^up
            return base.contains_func(target) ||
                down.contains_func(target) || up.contains_func(target);
        },
        DQ: function(target, base, down) {
            // base_down
            return base.contains_func(target) || down.contains_func(target);
        },
        UQ: function(target, base, up) {
            // base^up
            return base.contains_func(target) || up.contains_func(target);
        },
        FQN: function(target, down, up) {
            // _down^up (no base)
            return down.contains_func(target) || up.contains_func(target);
        },
        DQN: function(target, down) {
            // _down (no base)
            return down.contains_func(target);
        },
        UQN: function(target, up) {
            // ^up (no base)
            return up.contains_func(target);
        },
        LITERAL: function(target, r) {
            // a TeX literal.  It may contain function invocations in
            // certain specific forms; see the tex_contains method above.
            return r.tex_contains(target);
        },
        FUN1: function(target, f, a) {
            // {\f{a}}  (function of one argument)
            return target === f || a.contains_func(target);
        },
        FUN1nb: function(target, f, a) {
            // \f{a}  (function of one argument, "no braces" around outside)
            return target === f || a.contains_func(target);
        },
        FUN1hl: function(target, f, _, a) {
            // \f{a}  ... this is not currently generated by the parser
            return target === f || a.contains_func(target);
        },
        FUN1hf: function(target, f, _, a) {
            // \f{a}  ... this is not currently generated by the parser
            return target === f || a.contains_func(target);
        },
        DECLh: function(target, f, _, a) {
            // {\rm a1 a2 a3 a4 ...}  where f is \rm, \it, \cal, or \bf
            return target === f ||
                a.some(function(t) { return t.contains_func(target); });
        },
        FUN2: function(target, f, a, b) {
            // {\f{a}{b}}  (function of two arguments)
            return target === f ||
                a.contains_func(target) || b.contains_func(target);
        },
        FUN2h: function(target, f, _, a, b) {
            // \f{a}{b}  ... this is not currently generated by the parser
            return target === f ||
                a.contains_func(target) || b.contains_func(target);
        },
        FUN2nb: function(target, f, a, b) {
            // \f{a}{b}  (function of two arguments, "no braces" around outside)
            return target === f ||
                a.contains_func(target) || b.contains_func(target);
        },
        FUN2sq: function(target, f, a, b) {
            // {\f[a]{b}}  (function of two arguments, first is optional)
            return target === f ||
                a.contains_func(target) || b.contains_func(target);
        },
        CURLY: function(target, tl) {
            // { tl1 tl2 tl3 ... }
            return tl.some(function(t) { return t.contains_func(target); });
        },
        INFIX: function(target, s, ll, rl) {
            // { ll1 ll2 ... \s rl1 rl2 ... } (infix function)
            return s === target ||
                ll.some(function(t) { return t.contains_func(target); }) ||
                rl.some(function(t) { return t.contains_func(target); });
        },
        INFIXh: function(target, s, _, ll, rl) {
            // { ll1 ll2 ... \s rl1 rl2 ... } (infix function)
            // ... this is not currently generated by the parser
            return s === target ||
                ll.some(function(t) { return t.contains_func(target); }) ||
                rl.some(function(t) { return t.contains_func(target); });
        },
        BOX: function(target, box, s) {
            // \box{s} where box is \text, \mbox, \hbox, or \vbox
            //         and s is a string not containing special characters
            return box === target;
        },
        BIG: function(target, big, d) {
            // \big\d where big is \big, \Big, \bigg, \Bigg, \biggl, etc
            return big === target || d.tex_contains(target);
        },
        MATRIX: function(target, t, m) {
            // \begin{env} .. & .. \\ .. & .. \\ .. & .. \end{env}
            // t is the environment name.
            // m is a doubly-nested array
            var tex_has = function(t) { return t.contains_func(target); };
            var expr_has = function(e) { return e.some(tex_has); };
            var line_has = function(l) { return l.some(expr_has); };
            var matrix_has = function(m) { return m.some(line_has); };
            return target === ('\\begin{'+t+'}') ||
                target === ('\\end{'+t+'}') ||
                matrix_has(m);
        },
        LR: function(target, l, r, tl) {
            // \left\l tl1 tl2 tl3 ... \right\r  (a balanced pair of delimiters)
            return target === '\\left' || target === '\\right' ||
                l.tex_contains(target) || r.tex_contains(target) ||
                tl.some(function(t) { return t.contains_func(target); });
        }
    }, 1);

    var testcases = [
        { input: '\\left(abc\\right)',  yes: ['\\left', '\\right'] },
        { input: '\\sin(x)+\\cos(x)^2', yes: ['\\sin', '\\cos'] },
        { input: '\\big\\langle',       yes: ['\\big', '\\langle'] },
        { input: '\\arccot(x) \\atop \\aleph',
          yes: ['\\operatorname', '\\atop', '\\aleph'],
          no:  ['\\arccot'] },
        { input: '\\acute{\\euro\\alef}',
          yes: ['\\acute', '\\euro', '\\aleph', '\\mbox' ],
          no:  ['\\alef'] },
        { input: '\\sqrt[\\backslash]{\\darr}',
          yes: ['\\sqrt', '\\backslash', '\\downarrow'],
          no:  ['\\darr'] },
        { input: '\\mbox{abc}',         yes: ['\\mbox'] },
        { input: 'x_\\aleph^\\sqrt{2}', yes: ['\\aleph','\\sqrt'] },
        { input: '{abc \\rm def \\it ghi}', yes: ['\\rm','\\it'] },
        { input: '{\\frac{\\sideset{_\\dagger}{^\\bold{x}}\\prod}{\\hat{a}}}',
          yes: ['\\frac','\\sideset','\\dagger','\\mathbf','\\prod','\\hat'],
          no:  ['\\bold'] },
        { input: '\\begin{array}\n' +
                 '\\alpha & \\beta \\\\\n' +
                 '\\gamma & \\delta\n' +
                 '\\end{array}',
          yes: [ '\\begin{array}', '\\end{array}', '\\alpha', '\\beta',
                 '\\gamma', '\\delta' ],
          no:  [ '\\begin', '\\end', '\\hline' ]
        },
        { input: '\\color[rgb]{0,1,.2}',
          yes: [ '\\color' ],
          no: [ '\\c', 'rgb', '\\pagecolor', '\\definecolor' ]
        },
        { input: '\\definecolor{blue}{cmyk}{1,0,0,0}\\pagecolor{blue}',
          yes: [ '\\definecolor', '\\pagecolor' ],
          no: [ '\\color', 'cmyk', 'blue', '\\blue' ]
        }
    ];
    testcases.forEach(function(tc) {
        tc.no = (tc.no || []).concat(['\\foo', '\\begin{foo}']);
        [false,true].forEach(function(expected) {
            (expected ? tc.yes : tc.no).forEach(function(target) {
                it('should ' + (expected ? '' : 'not ') + 'find ' + target +
                   ' in ' + tc.input.replace(/\n/g,' '), function() {
                       var p = texvcjs.parse(tc.input, { debug: true }).result;
                       var contains_func = function(t) {
                               return t.contains_func(target);
                       };
                       assert.equal(p.some(contains_func), expected);
                   });
            });
        });
    });
});
