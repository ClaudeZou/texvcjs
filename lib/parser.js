/* jshint latedef: nofunc */
"use strict";
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    /*jshint validthis:true, newcap:false */
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = peg$FAILED,
        peg$c1 = function(t) { console.assert(t instanceof ast.LList);
              context.result = t.toArray();
              return context;
            },
        peg$c2 = [],
        peg$c3 = /^[ \t\n\r]/,
        peg$c4 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },
        peg$c5 = function(e) { return e; },
        peg$c6 = function(e1, name, e2) { return ast.LList(ast.Tex.INFIX(name, e1.toArray(), e2.toArray())); },
        peg$c7 = function(e1, f, e2) { return ast.LList(ast.Tex.INFIXh(f[0], f[1], e1.toArray(), e2.toArray()));},
        peg$c8 = function() { return ast.LList.EMPTY; },
        peg$c9 = function(h, t) { return ast.LList(h, t); },
        peg$c10 = function(d, e) { return ast.LList(ast.Tex.DECLh(d[0], d[1], e.toArray())); },
        peg$c11 = function(l1, l2) { return ast.Tex.FQ(l1[0], l1[1], l2); },
        peg$c12 = function(l1, l2) { return ast.Tex.FQ(l1[0], l2, l1[1]); },
        peg$c13 = function(base, upi) { return ast.Tex.UQ(base, upi); },
        peg$c14 = function(base, downi) { return ast.Tex.DQ(base, downi); },
        peg$c15 = function() { return ast.Tex.LITERAL(sq_close_ri); },
        peg$c16 = function(l, e) { return ast.LList(l, e); },
        peg$c17 = function(l1, l2) { return ast.Tex.FQN(l1[0], l2); },
        peg$c18 = function(l) { return ast.Tex.UQN(l); },
        peg$c19 = function(l) { return ast.Tex.DQN(l); },
        peg$c20 = function(d) { return d; },
        peg$c21 = function() { return sq_close_ri; },
        peg$c22 = function(r) { return ast.Tex.LITERAL(r); },
        peg$c23 = function(b, r) { return ast.Tex.BIG(b, r); },
        peg$c24 = function(b) { return ast.Tex.BIG(b, sq_close_ri); },
        peg$c25 = function(l, e, r) { return ast.Tex.LR(l, r, e.toArray()); },
        peg$c26 = function(name, e, l) { return ast.Tex.FUN2sq(name, ast.Tex.CURLY(e.toArray()), l); },
        peg$c27 = function(name, l) { return ast.Tex.FUN1(name, l); },
        peg$c28 = function(name, l) { return ast.Tex.FUN1nb(name, l); },
        peg$c29 = function(f, l) { return ast.Tex.FUN1hl(f[0], f[1], l); },
        peg$c30 = function(f, l) { return ast.Tex.FUN1hf(f[0], f[1], l); },
        peg$c31 = function(name, l1, l2) { return ast.Tex.FUN2(name, l1, l2); },
        peg$c32 = function(name, l1, l2) { return ast.Tex.FUN2nb(name, l1, l2); },
        peg$c33 = function(f, l1, l2) { return ast.Tex.FUN2h(f[0], f[1], l1, l2); },
        peg$c34 = function(e) { return ast.Tex.CURLY(e.toArray()); },
        peg$c35 = function(e1, name, e2) { return ast.Tex.INFIX(name, e1.toArray(), e2.toArray()); },
        peg$c36 = function(e1, f, e2) { return ast.Tex.INFIXh(f[0], f[1], e1.toArray(), e2.toArray()); },
        peg$c37 = function(m) { return ast.Tex.MATRIX("matrix", lst2arr(m)); },
        peg$c38 = function(m) { return ast.Tex.MATRIX("pmatrix", lst2arr(m)); },
        peg$c39 = function(m) { return ast.Tex.MATRIX("bmatrix", lst2arr(m)); },
        peg$c40 = function(m) { return ast.Tex.MATRIX("Bmatrix", lst2arr(m)); },
        peg$c41 = function(m) { return ast.Tex.MATRIX("vmatrix", lst2arr(m)); },
        peg$c42 = function(m) { return ast.Tex.MATRIX("Vmatrix", lst2arr(m)); },
        peg$c43 = function(m) { return ast.Tex.MATRIX("array", lst2arr(m)); },
        peg$c44 = function(m) { return ast.Tex.MATRIX("aligned", lst2arr(m)); },
        peg$c45 = function(m) { return ast.Tex.MATRIX("alignedat", lst2arr(m)); },
        peg$c46 = function(m) { return ast.Tex.MATRIX("smallmatrix", lst2arr(m)); },
        peg$c47 = function(m) { return ast.Tex.MATRIX("cases", lst2arr(m)); },
        peg$c48 = "\\begin{",
        peg$c49 = { type: "literal", value: "\\begin{", description: "\"\\\\begin{\"" },
        peg$c50 = "}",
        peg$c51 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c52 = function() { throw new SyntaxError("Illegal TeX function", [], text(), offset(), line(), column()); },
        peg$c53 = function(f) { return !all_functions[f]; },
        peg$c54 = void 0,
        peg$c55 = function(f) { throw new SyntaxError("Illegal TeX function", [], f, offset(), line(), column()); },
        peg$c56 = null,
        peg$c57 = function(m) { return m; },
        peg$c58 = function(l, tail) { return { head: lst2arr(l), tail: tail }; },
        peg$c59 = function(f, l) { l.head.unshift(ast.Tex.LITERAL(ast.RenderT.TEX_ONLY(f + " "))); return l;},
        peg$c60 = function(l) { return l; },
        peg$c61 = function(e, tail) { return { head: e.toArray(), tail: tail }; },
        peg$c62 = /^[a-zA-Z]/,
        peg$c63 = { type: "class", value: "[a-zA-Z]", description: "[a-zA-Z]" },
        peg$c64 = /^[0-9]/,
        peg$c65 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c66 = /^[,:;?!']/,
        peg$c67 = { type: "class", value: "[,:;?!']", description: "[,:;?!']" },
        peg$c68 = /^[().]/,
        peg$c69 = { type: "class", value: "[().]", description: "[().]" },
        peg$c70 = /^[\-+*=]/,
        peg$c71 = { type: "class", value: "[\\-+*=]", description: "[\\-+*=]" },
        peg$c72 = /^[\/|]/,
        peg$c73 = { type: "class", value: "[\\/|]", description: "[\\/|]" },
        peg$c74 = /^[\-0-9a-zA-Z+*,=():\/;?.!'` \x80-\xFF]/,
        peg$c75 = { type: "class", value: "[\\-0-9a-zA-Z+*,=():\\/;?.!'` \\x80-\\xFF]", description: "[\\-0-9a-zA-Z+*,=():\\/;?.!'` \\x80-\\xFF]" },
        peg$c76 = function(b) { return box_functions[b]; },
        peg$c77 = "{",
        peg$c78 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c79 = function(b, cs) { return ast.Tex.BOX(b, cs.join('')); },
        peg$c80 = "-",
        peg$c81 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c82 = function(c) { return ast.RenderT.TEX_ONLY(c); },
        peg$c83 = function(f) { return latex_function_names[f]; },
        peg$c84 = "(",
        peg$c85 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c86 = "[",
        peg$c87 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c88 = "\\{",
        peg$c89 = { type: "literal", value: "\\{", description: "\"\\\\{\"" },
        peg$c90 = function() { return " ";},
        peg$c91 = function(f, c) { return ast.RenderT.TEX_ONLY(f + c); },
        peg$c92 = function(f) { return mediawiki_function_names[f]; },
        peg$c93 = function(f, c) { return ast.RenderT.TEX_ONLY("\\operatorname {" + f.slice(1) + "}" + c); },
        peg$c94 = function(f) { return other_literals1[f]; },
        peg$c95 = function(f) { return ast.RenderT.TEX_ONLY(f + " "); },
        peg$c96 = function(f) { return other_literals2[f]; },
        peg$c97 = function(f) { return ast.RenderT.TEX_ONLY("\\mbox{" + f + "} "); },
        peg$c98 = function(mbox) { return mbox === "\\mbox"; },
        peg$c99 = function(mbox, f) { return other_literals2[f]; },
        peg$c100 = function(mbox, f) { return ast.RenderT.TEX_ONLY("\\mbox{" + f + "} "); },
        peg$c101 = function(f) { return other_literals3[f]; },
        peg$c102 = function(f) { return ast.RenderT.TEX_ONLY(other_literals3[f] + " "); },
        peg$c103 = "\\",
        peg$c104 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c105 = /^[, ;!_#%$&]/,
        peg$c106 = { type: "class", value: "[, ;!_#%$&]", description: "[, ;!_#%$&]" },
        peg$c107 = function(c) { return ast.RenderT.TEX_ONLY("\\" + c); },
        peg$c108 = /^[><~]/,
        peg$c109 = { type: "class", value: "[><~]", description: "[><~]" },
        peg$c110 = /^[%$]/,
        peg$c111 = { type: "class", value: "[%$]", description: "[%$]" },
        peg$c112 = function(c) { return ast.RenderT.TEX_ONLY("\\" + c); /* escape dangerous chars */},
        peg$c113 = /^[{}|]/,
        peg$c114 = { type: "class", value: "[{}|]", description: "[{}|]" },
        peg$c115 = function(f) { return other_delimiters1[f]; },
        peg$c116 = function(f) { return other_delimiters2[f]; },
        peg$c117 = function(f) { return ast.RenderT.TEX_ONLY(other_delimiters2[f] + " "); },
        peg$c118 = function(f) { return fun_ar1nb[f]; },
        peg$c119 = function(f) { return f; },
        peg$c120 = function(f) { return fun_ar1opt[f]; },
        peg$c121 = "&",
        peg$c122 = { type: "literal", value: "&", description: "\"&\"" },
        peg$c123 = "\\\\",
        peg$c124 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
        peg$c125 = "\\begin{matrix}",
        peg$c126 = { type: "literal", value: "\\begin{matrix}", description: "\"\\\\begin{matrix}\"" },
        peg$c127 = "\\end{matrix}",
        peg$c128 = { type: "literal", value: "\\end{matrix}", description: "\"\\\\end{matrix}\"" },
        peg$c129 = "\\begin{pmatrix}",
        peg$c130 = { type: "literal", value: "\\begin{pmatrix}", description: "\"\\\\begin{pmatrix}\"" },
        peg$c131 = "\\end{pmatrix}",
        peg$c132 = { type: "literal", value: "\\end{pmatrix}", description: "\"\\\\end{pmatrix}\"" },
        peg$c133 = "\\begin{bmatrix}",
        peg$c134 = { type: "literal", value: "\\begin{bmatrix}", description: "\"\\\\begin{bmatrix}\"" },
        peg$c135 = "\\end{bmatrix}",
        peg$c136 = { type: "literal", value: "\\end{bmatrix}", description: "\"\\\\end{bmatrix}\"" },
        peg$c137 = "\\begin{Bmatrix}",
        peg$c138 = { type: "literal", value: "\\begin{Bmatrix}", description: "\"\\\\begin{Bmatrix}\"" },
        peg$c139 = "\\end{Bmatrix}",
        peg$c140 = { type: "literal", value: "\\end{Bmatrix}", description: "\"\\\\end{Bmatrix}\"" },
        peg$c141 = "\\begin{vmatrix}",
        peg$c142 = { type: "literal", value: "\\begin{vmatrix}", description: "\"\\\\begin{vmatrix}\"" },
        peg$c143 = "\\end{vmatrix}",
        peg$c144 = { type: "literal", value: "\\end{vmatrix}", description: "\"\\\\end{vmatrix}\"" },
        peg$c145 = "\\begin{Vmatrix}",
        peg$c146 = { type: "literal", value: "\\begin{Vmatrix}", description: "\"\\\\begin{Vmatrix}\"" },
        peg$c147 = "\\end{Vmatrix}",
        peg$c148 = { type: "literal", value: "\\end{Vmatrix}", description: "\"\\\\end{Vmatrix}\"" },
        peg$c149 = "\\begin{array}",
        peg$c150 = { type: "literal", value: "\\begin{array}", description: "\"\\\\begin{array}\"" },
        peg$c151 = "\\end{array}",
        peg$c152 = { type: "literal", value: "\\end{array}", description: "\"\\\\end{array}\"" },
        peg$c153 = "\\begin{align}",
        peg$c154 = { type: "literal", value: "\\begin{align}", description: "\"\\\\begin{align}\"" },
        peg$c155 = "\\end{align}",
        peg$c156 = { type: "literal", value: "\\end{align}", description: "\"\\\\end{align}\"" },
        peg$c157 = "\\begin{aligned}",
        peg$c158 = { type: "literal", value: "\\begin{aligned}", description: "\"\\\\begin{aligned}\"" },
        peg$c159 = "\\end{aligned}",
        peg$c160 = { type: "literal", value: "\\end{aligned}", description: "\"\\\\end{aligned}\"" },
        peg$c161 = "\\begin{alignat}",
        peg$c162 = { type: "literal", value: "\\begin{alignat}", description: "\"\\\\begin{alignat}\"" },
        peg$c163 = "\\end{alignat}",
        peg$c164 = { type: "literal", value: "\\end{alignat}", description: "\"\\\\end{alignat}\"" },
        peg$c165 = "\\begin{alignedat}",
        peg$c166 = { type: "literal", value: "\\begin{alignedat}", description: "\"\\\\begin{alignedat}\"" },
        peg$c167 = "\\end{alignedat}",
        peg$c168 = { type: "literal", value: "\\end{alignedat}", description: "\"\\\\end{alignedat}\"" },
        peg$c169 = "\\begin{smallmatrix}",
        peg$c170 = { type: "literal", value: "\\begin{smallmatrix}", description: "\"\\\\begin{smallmatrix}\"" },
        peg$c171 = "\\end{smallmatrix}",
        peg$c172 = { type: "literal", value: "\\end{smallmatrix}", description: "\"\\\\end{smallmatrix}\"" },
        peg$c173 = "\\begin{cases}",
        peg$c174 = { type: "literal", value: "\\begin{cases}", description: "\"\\\\begin{cases}\"" },
        peg$c175 = "\\end{cases}",
        peg$c176 = { type: "literal", value: "\\end{cases}", description: "\"\\\\end{cases}\"" },
        peg$c177 = "]",
        peg$c178 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c179 = "^",
        peg$c180 = { type: "literal", value: "^", description: "\"^\"" },
        peg$c181 = "_",
        peg$c182 = { type: "literal", value: "_", description: "\"_\"" },
        peg$c183 = function() { return text(); },
        peg$c184 = function(f) { return big_literals[f]; },
        peg$c185 = function(f) { return fun_ar1[f]; },
        peg$c186 = function(f) { return other_fun_ar1[f]; },
        peg$c187 = function(f) { return fun_ar2[f]; },
        peg$c188 = function(f) { return fun_infix[f]; },
        peg$c189 = function(f) { return declh_function[f]; },
        peg$c190 = function(f) { return ast.Tex.DECLh(f, ast.FontForce.RM(), []); /*see bug 54818*/ },
        peg$c191 = function(f) { return fun_ar2nb[f]; },
        peg$c192 = function(f) { return left_function[f]; },
        peg$c193 = function(f) { return right_function[f]; },
        peg$c194 = function(f) { return hline_function[f]; },
        peg$c195 = function() { return false; },
        peg$c196 = function() { return peg$currPos === input.length; },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$cache = {},
        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1 ?
          expectedDescs.slice(0, -1).join(", ") +
              " or " +
              expectedDescs[expected.length - 1] :
          expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 0,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsetex_expr();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c1(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parse_() {
      var s0, s1;

      var key    = peg$currPos * 81 + 1,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = [];
      if (peg$c3.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c3.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c4); }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetex_expr() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 81 + 2,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseexpr();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseEOF();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c5(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsene_expr();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseFUN_INFIX();
          if (s2 !== peg$FAILED) {
            s3 = peg$parsene_expr();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseEOF();
              if (s4 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c6(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsene_expr();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseimpossible();
            if (s2 !== peg$FAILED) {
              s3 = peg$parsene_expr();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseEOF();
                if (s4 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c7(s1, s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpr() {
      var s0, s1;

      var key    = peg$currPos * 81 + 3,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parsene_expr();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c8();
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsene_expr() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 4,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselit_aq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexpr();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c9(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parselitsq_aq();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseexpr();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c9(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseDECLh();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseexpr();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c10(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselitsq_aq() {
      var s0;

      var key    = peg$currPos * 81 + 5,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parselitsq_fq();
      if (s0 === peg$FAILED) {
        s0 = peg$parselitsq_dq();
        if (s0 === peg$FAILED) {
          s0 = peg$parselitsq_uq();
          if (s0 === peg$FAILED) {
            s0 = peg$parselitsq_zq();
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselitsq_fq() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 6,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselitsq_dq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSUP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselit();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c11(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parselitsq_uq();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseSUB();
          if (s2 !== peg$FAILED) {
            s3 = peg$parselit();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c12(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselitsq_uq() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 7,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselitsq_zq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSUP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselit();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselitsq_dq() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 8,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselitsq_zq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSUB();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselit();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c14(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselitsq_zq() {
      var s0, s1;

      var key    = peg$currPos * 81 + 9,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseSQ_CLOSE();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c15();
      }
      s0 = s1;

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpr_nosqc() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 10,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselit_aq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexpr_nosqc();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c16(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c8();
        }
        s0 = s1;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselit_aq() {
      var s0;

      var key    = peg$currPos * 81 + 11,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$parselit_fq();
      if (s0 === peg$FAILED) {
        s0 = peg$parselit_dq();
        if (s0 === peg$FAILED) {
          s0 = peg$parselit_uq();
          if (s0 === peg$FAILED) {
            s0 = peg$parselit_dqn();
            if (s0 === peg$FAILED) {
              s0 = peg$parselit_uqn();
              if (s0 === peg$FAILED) {
                s0 = peg$parselit();
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselit_fq() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 12,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselit_dq();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSUP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselit();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c11(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parselit_uq();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseSUB();
          if (s2 !== peg$FAILED) {
            s3 = peg$parselit();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c12(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parselit_dqn();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSUP();
            if (s2 !== peg$FAILED) {
              s3 = peg$parselit();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c17(s1, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselit_uq() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 13,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselit();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSUP();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselit();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselit_dq() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 14,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parselit();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseSUB();
        if (s2 !== peg$FAILED) {
          s3 = peg$parselit();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c14(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselit_uqn() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 15,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseSUP();
      if (s1 !== peg$FAILED) {
        s2 = peg$parselit();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c18(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselit_dqn() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 16,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseSUB();
      if (s1 !== peg$FAILED) {
        s2 = peg$parselit();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c19(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseleft() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 17,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseLEFT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDELIMITER();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c20(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseLEFT();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseSQ_CLOSE();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseright() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 18,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseRIGHT();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseDELIMITER();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c20(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseRIGHT();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseSQ_CLOSE();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c21();
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parselit() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 81 + 19,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseLITERAL();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c22(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseDELIMITER();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c22(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseBIG();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDELIMITER();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c23(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseBIG();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseSQ_CLOSE();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c24(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseleft();
              if (s1 !== peg$FAILED) {
                s2 = peg$parseexpr();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parseright();
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c25(s1, s2, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseFUN_AR1opt();
                if (s1 !== peg$FAILED) {
                  s2 = peg$parseexpr_nosqc();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parseSQ_CLOSE();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parselit();
                      if (s4 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c26(s1, s2, s4);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseFUN_AR1();
                  if (s1 !== peg$FAILED) {
                    s2 = peg$parselit();
                    if (s2 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c27(s1, s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    s1 = peg$parseFUN_AR1nb();
                    if (s1 !== peg$FAILED) {
                      s2 = peg$parselit();
                      if (s2 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c28(s1, s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      s1 = peg$parseimpossible();
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parselit();
                        if (s2 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c29(s1, s2);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        s1 = peg$parseimpossible();
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parselit();
                          if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c30(s1, s2);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                        if (s0 === peg$FAILED) {
                          s0 = peg$currPos;
                          s1 = peg$parseFUN_AR2();
                          if (s1 !== peg$FAILED) {
                            s2 = peg$parselit();
                            if (s2 !== peg$FAILED) {
                              s3 = peg$parselit();
                              if (s3 !== peg$FAILED) {
                                peg$reportedPos = s0;
                                s1 = peg$c31(s1, s2, s3);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                          if (s0 === peg$FAILED) {
                            s0 = peg$currPos;
                            s1 = peg$parseFUN_AR2nb();
                            if (s1 !== peg$FAILED) {
                              s2 = peg$parselit();
                              if (s2 !== peg$FAILED) {
                                s3 = peg$parselit();
                                if (s3 !== peg$FAILED) {
                                  peg$reportedPos = s0;
                                  s1 = peg$c32(s1, s2, s3);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$currPos;
                              s1 = peg$parseimpossible();
                              if (s1 !== peg$FAILED) {
                                s2 = peg$parselit();
                                if (s2 !== peg$FAILED) {
                                  s3 = peg$parselit();
                                  if (s3 !== peg$FAILED) {
                                    peg$reportedPos = s0;
                                    s1 = peg$c33(s1, s2, s3);
                                    s0 = s1;
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                              if (s0 === peg$FAILED) {
                                s0 = peg$parseBOX();
                                if (s0 === peg$FAILED) {
                                  s0 = peg$currPos;
                                  s1 = peg$parseCURLY_OPEN();
                                  if (s1 !== peg$FAILED) {
                                    s2 = peg$parseexpr();
                                    if (s2 !== peg$FAILED) {
                                      s3 = peg$parseCURLY_CLOSE();
                                      if (s3 !== peg$FAILED) {
                                        peg$reportedPos = s0;
                                        s1 = peg$c34(s2);
                                        s0 = s1;
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                  } else {
                                    peg$currPos = s0;
                                    s0 = peg$c0;
                                  }
                                  if (s0 === peg$FAILED) {
                                    s0 = peg$currPos;
                                    s1 = peg$parseCURLY_OPEN();
                                    if (s1 !== peg$FAILED) {
                                      s2 = peg$parsene_expr();
                                      if (s2 !== peg$FAILED) {
                                        s3 = peg$parseFUN_INFIX();
                                        if (s3 !== peg$FAILED) {
                                          s4 = peg$parsene_expr();
                                          if (s4 !== peg$FAILED) {
                                            s5 = peg$parseCURLY_CLOSE();
                                            if (s5 !== peg$FAILED) {
                                              peg$reportedPos = s0;
                                              s1 = peg$c35(s2, s3, s4);
                                              s0 = s1;
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$c0;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                    } else {
                                      peg$currPos = s0;
                                      s0 = peg$c0;
                                    }
                                    if (s0 === peg$FAILED) {
                                      s0 = peg$currPos;
                                      s1 = peg$parseCURLY_OPEN();
                                      if (s1 !== peg$FAILED) {
                                        s2 = peg$parsene_expr();
                                        if (s2 !== peg$FAILED) {
                                          s3 = peg$parseimpossible();
                                          if (s3 !== peg$FAILED) {
                                            s4 = peg$parsene_expr();
                                            if (s4 !== peg$FAILED) {
                                              s5 = peg$parseCURLY_CLOSE();
                                              if (s5 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c36(s2, s3, s4);
                                                s0 = s1;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$c0;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$c0;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                      } else {
                                        peg$currPos = s0;
                                        s0 = peg$c0;
                                      }
                                      if (s0 === peg$FAILED) {
                                        s0 = peg$currPos;
                                        s1 = peg$parseBEGIN_MATRIX();
                                        if (s1 !== peg$FAILED) {
                                          s2 = peg$parsematrix();
                                          if (s2 !== peg$FAILED) {
                                            s3 = peg$parseEND_MATRIX();
                                            if (s3 !== peg$FAILED) {
                                              peg$reportedPos = s0;
                                              s1 = peg$c37(s2);
                                              s0 = s1;
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$c0;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                        } else {
                                          peg$currPos = s0;
                                          s0 = peg$c0;
                                        }
                                        if (s0 === peg$FAILED) {
                                          s0 = peg$currPos;
                                          s1 = peg$parseBEGIN_PMATRIX();
                                          if (s1 !== peg$FAILED) {
                                            s2 = peg$parsematrix();
                                            if (s2 !== peg$FAILED) {
                                              s3 = peg$parseEND_PMATRIX();
                                              if (s3 !== peg$FAILED) {
                                                peg$reportedPos = s0;
                                                s1 = peg$c38(s2);
                                                s0 = s1;
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$c0;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$c0;
                                            }
                                          } else {
                                            peg$currPos = s0;
                                            s0 = peg$c0;
                                          }
                                          if (s0 === peg$FAILED) {
                                            s0 = peg$currPos;
                                            s1 = peg$parseBEGIN_BMATRIX();
                                            if (s1 !== peg$FAILED) {
                                              s2 = peg$parsematrix();
                                              if (s2 !== peg$FAILED) {
                                                s3 = peg$parseEND_BMATRIX();
                                                if (s3 !== peg$FAILED) {
                                                  peg$reportedPos = s0;
                                                  s1 = peg$c39(s2);
                                                  s0 = s1;
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$c0;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$c0;
                                              }
                                            } else {
                                              peg$currPos = s0;
                                              s0 = peg$c0;
                                            }
                                            if (s0 === peg$FAILED) {
                                              s0 = peg$currPos;
                                              s1 = peg$parseBEGIN_BBMATRIX();
                                              if (s1 !== peg$FAILED) {
                                                s2 = peg$parsematrix();
                                                if (s2 !== peg$FAILED) {
                                                  s3 = peg$parseEND_BBMATRIX();
                                                  if (s3 !== peg$FAILED) {
                                                    peg$reportedPos = s0;
                                                    s1 = peg$c40(s2);
                                                    s0 = s1;
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c0;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$c0;
                                                }
                                              } else {
                                                peg$currPos = s0;
                                                s0 = peg$c0;
                                              }
                                              if (s0 === peg$FAILED) {
                                                s0 = peg$currPos;
                                                s1 = peg$parseBEGIN_VMATRIX();
                                                if (s1 !== peg$FAILED) {
                                                  s2 = peg$parsematrix();
                                                  if (s2 !== peg$FAILED) {
                                                    s3 = peg$parseEND_VMATRIX();
                                                    if (s3 !== peg$FAILED) {
                                                      peg$reportedPos = s0;
                                                      s1 = peg$c41(s2);
                                                      s0 = s1;
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$c0;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c0;
                                                  }
                                                } else {
                                                  peg$currPos = s0;
                                                  s0 = peg$c0;
                                                }
                                                if (s0 === peg$FAILED) {
                                                  s0 = peg$currPos;
                                                  s1 = peg$parseBEGIN_VVMATRIX();
                                                  if (s1 !== peg$FAILED) {
                                                    s2 = peg$parsematrix();
                                                    if (s2 !== peg$FAILED) {
                                                      s3 = peg$parseEND_VVMATRIX();
                                                      if (s3 !== peg$FAILED) {
                                                        peg$reportedPos = s0;
                                                        s1 = peg$c42(s2);
                                                        s0 = s1;
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c0;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$c0;
                                                    }
                                                  } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$c0;
                                                  }
                                                  if (s0 === peg$FAILED) {
                                                    s0 = peg$currPos;
                                                    s1 = peg$parseBEGIN_ARRAY();
                                                    if (s1 !== peg$FAILED) {
                                                      s2 = peg$parsematrix();
                                                      if (s2 !== peg$FAILED) {
                                                        s3 = peg$parseEND_ARRAY();
                                                        if (s3 !== peg$FAILED) {
                                                          peg$reportedPos = s0;
                                                          s1 = peg$c43(s2);
                                                          s0 = s1;
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$c0;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c0;
                                                      }
                                                    } else {
                                                      peg$currPos = s0;
                                                      s0 = peg$c0;
                                                    }
                                                    if (s0 === peg$FAILED) {
                                                      s0 = peg$currPos;
                                                      s1 = peg$parseBEGIN_ALIGN();
                                                      if (s1 !== peg$FAILED) {
                                                        s2 = peg$parsematrix();
                                                        if (s2 !== peg$FAILED) {
                                                          s3 = peg$parseEND_ALIGN();
                                                          if (s3 !== peg$FAILED) {
                                                            peg$reportedPos = s0;
                                                            s1 = peg$c44(s2);
                                                            s0 = s1;
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c0;
                                                          }
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$c0;
                                                        }
                                                      } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$c0;
                                                      }
                                                      if (s0 === peg$FAILED) {
                                                        s0 = peg$currPos;
                                                        s1 = peg$parseBEGIN_ALIGNED();
                                                        if (s1 !== peg$FAILED) {
                                                          s2 = peg$parsematrix();
                                                          if (s2 !== peg$FAILED) {
                                                            s3 = peg$parseEND_ALIGNED();
                                                            if (s3 !== peg$FAILED) {
                                                              peg$reportedPos = s0;
                                                              s1 = peg$c44(s2);
                                                              s0 = s1;
                                                            } else {
                                                              peg$currPos = s0;
                                                              s0 = peg$c0;
                                                            }
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c0;
                                                          }
                                                        } else {
                                                          peg$currPos = s0;
                                                          s0 = peg$c0;
                                                        }
                                                        if (s0 === peg$FAILED) {
                                                          s0 = peg$currPos;
                                                          s1 = peg$parseBEGIN_ALIGNAT();
                                                          if (s1 !== peg$FAILED) {
                                                            s2 = peg$parsematrix();
                                                            if (s2 !== peg$FAILED) {
                                                              s3 = peg$parseEND_ALIGNAT();
                                                              if (s3 !== peg$FAILED) {
                                                                peg$reportedPos = s0;
                                                                s1 = peg$c45(s2);
                                                                s0 = s1;
                                                              } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$c0;
                                                              }
                                                            } else {
                                                              peg$currPos = s0;
                                                              s0 = peg$c0;
                                                            }
                                                          } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$c0;
                                                          }
                                                          if (s0 === peg$FAILED) {
                                                            s0 = peg$currPos;
                                                            s1 = peg$parseBEGIN_ALIGNEDAT();
                                                            if (s1 !== peg$FAILED) {
                                                              s2 = peg$parsematrix();
                                                              if (s2 !== peg$FAILED) {
                                                                s3 = peg$parseEND_ALIGNEDAT();
                                                                if (s3 !== peg$FAILED) {
                                                                  peg$reportedPos = s0;
                                                                  s1 = peg$c45(s2);
                                                                  s0 = s1;
                                                                } else {
                                                                  peg$currPos = s0;
                                                                  s0 = peg$c0;
                                                                }
                                                              } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$c0;
                                                              }
                                                            } else {
                                                              peg$currPos = s0;
                                                              s0 = peg$c0;
                                                            }
                                                            if (s0 === peg$FAILED) {
                                                              s0 = peg$currPos;
                                                              s1 = peg$parseBEGIN_SMALLMATRIX();
                                                              if (s1 !== peg$FAILED) {
                                                                s2 = peg$parsematrix();
                                                                if (s2 !== peg$FAILED) {
                                                                  s3 = peg$parseEND_SMALLMATRIX();
                                                                  if (s3 !== peg$FAILED) {
                                                                    peg$reportedPos = s0;
                                                                    s1 = peg$c46(s2);
                                                                    s0 = s1;
                                                                  } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$c0;
                                                                  }
                                                                } else {
                                                                  peg$currPos = s0;
                                                                  s0 = peg$c0;
                                                                }
                                                              } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$c0;
                                                              }
                                                              if (s0 === peg$FAILED) {
                                                                s0 = peg$currPos;
                                                                s1 = peg$parseBEGIN_CASES();
                                                                if (s1 !== peg$FAILED) {
                                                                  s2 = peg$parsematrix();
                                                                  if (s2 !== peg$FAILED) {
                                                                    s3 = peg$parseEND_CASES();
                                                                    if (s3 !== peg$FAILED) {
                                                                      peg$reportedPos = s0;
                                                                      s1 = peg$c47(s2);
                                                                      s0 = s1;
                                                                    } else {
                                                                      peg$currPos = s0;
                                                                      s0 = peg$c0;
                                                                    }
                                                                  } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$c0;
                                                                  }
                                                                } else {
                                                                  peg$currPos = s0;
                                                                  s0 = peg$c0;
                                                                }
                                                                if (s0 === peg$FAILED) {
                                                                  s0 = peg$currPos;
                                                                  if (input.substr(peg$currPos, 7) === peg$c48) {
                                                                    s1 = peg$c48;
                                                                    peg$currPos += 7;
                                                                  } else {
                                                                    s1 = peg$FAILED;
                                                                    if (peg$silentFails === 0) { peg$fail(peg$c49); }
                                                                  }
                                                                  if (s1 !== peg$FAILED) {
                                                                    s2 = [];
                                                                    s3 = peg$parsealpha();
                                                                    if (s3 !== peg$FAILED) {
                                                                      while (s3 !== peg$FAILED) {
                                                                        s2.push(s3);
                                                                        s3 = peg$parsealpha();
                                                                      }
                                                                    } else {
                                                                      s2 = peg$c0;
                                                                    }
                                                                    if (s2 !== peg$FAILED) {
                                                                      if (input.charCodeAt(peg$currPos) === 125) {
                                                                        s3 = peg$c50;
                                                                        peg$currPos++;
                                                                      } else {
                                                                        s3 = peg$FAILED;
                                                                        if (peg$silentFails === 0) { peg$fail(peg$c51); }
                                                                      }
                                                                      if (s3 !== peg$FAILED) {
                                                                        peg$reportedPos = s0;
                                                                        s1 = peg$c52();
                                                                        s0 = s1;
                                                                      } else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$c0;
                                                                      }
                                                                    } else {
                                                                      peg$currPos = s0;
                                                                      s0 = peg$c0;
                                                                    }
                                                                  } else {
                                                                    peg$currPos = s0;
                                                                    s0 = peg$c0;
                                                                  }
                                                                  if (s0 === peg$FAILED) {
                                                                    s0 = peg$currPos;
                                                                    s1 = peg$parsegeneric_func();
                                                                    if (s1 !== peg$FAILED) {
                                                                      peg$reportedPos = peg$currPos;
                                                                      s2 = peg$c53(s1);
                                                                      if (s2) {
                                                                        s2 = peg$c54;
                                                                      } else {
                                                                        s2 = peg$c0;
                                                                      }
                                                                      if (s2 !== peg$FAILED) {
                                                                        peg$reportedPos = s0;
                                                                        s1 = peg$c55(s1);
                                                                        s0 = s1;
                                                                      } else {
                                                                        peg$currPos = s0;
                                                                        s0 = peg$c0;
                                                                      }
                                                                    } else {
                                                                      peg$currPos = s0;
                                                                      s0 = peg$c0;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsematrix() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 81 + 20,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseline_start();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseNEXT_ROW();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsematrix();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s2;
            s3 = peg$c57(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c56;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c58(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseline_start() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 21,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseHLINE();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseline_start();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c59(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseline();
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseline() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 81 + 22,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseexpr();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$parseNEXT_CELL();
        if (s3 !== peg$FAILED) {
          s4 = peg$parseline();
          if (s4 !== peg$FAILED) {
            peg$reportedPos = s2;
            s3 = peg$c60(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$c0;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c56;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c61(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsealpha() {
      var s0;

      var key    = peg$currPos * 81 + 23,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c62.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c63); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteral_id() {
      var s0;

      var key    = peg$currPos * 81 + 24,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c62.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c63); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteral_mn() {
      var s0;

      var key    = peg$currPos * 81 + 25,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c64.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteral_uf_lt() {
      var s0;

      var key    = peg$currPos * 81 + 26,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c66.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedelimiter_uf_lt() {
      var s0;

      var key    = peg$currPos * 81 + 27,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c68.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c69); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteral_uf_op() {
      var s0;

      var key    = peg$currPos * 81 + 28,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c70.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c71); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedelimiter_uf_op() {
      var s0;

      var key    = peg$currPos * 81 + 29,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c72.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseboxchars() {
      var s0;

      var key    = peg$currPos * 81 + 30,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      if (peg$c74.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c75); }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBOX() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 81 + 31,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c76(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c77;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c78); }
            }
            if (s4 !== peg$FAILED) {
              s5 = [];
              s6 = peg$parseboxchars();
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseboxchars();
                }
              } else {
                s5 = peg$c0;
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c50;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c51); }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c79(s1, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseLITERAL() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      var key    = peg$currPos * 81 + 32,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseliteral_id();
      if (s1 === peg$FAILED) {
        s1 = peg$parseliteral_mn();
        if (s1 === peg$FAILED) {
          s1 = peg$parseliteral_uf_lt();
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s1 = peg$c80;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c81); }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$parseliteral_uf_op();
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c82(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsegeneric_func();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = peg$currPos;
          s2 = peg$c83(s1);
          if (s2) {
            s2 = peg$c54;
          } else {
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 40) {
                s4 = peg$c84;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c85); }
              }
              if (s4 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 91) {
                  s4 = peg$c86;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c87); }
                }
                if (s4 === peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c88) {
                    s4 = peg$c88;
                    peg$currPos += 2;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c89); }
                  }
                  if (s4 === peg$FAILED) {
                    s4 = peg$currPos;
                    s5 = [];
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s4;
                      s5 = peg$c90();
                    }
                    s4 = s5;
                  }
                }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c91(s1, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsegeneric_func();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = peg$currPos;
            s2 = peg$c92(s1);
            if (s2) {
              s2 = peg$c54;
            } else {
              s2 = peg$c0;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 40) {
                  s4 = peg$c84;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c85); }
                }
                if (s4 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 91) {
                    s4 = peg$c86;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c87); }
                  }
                  if (s4 === peg$FAILED) {
                    if (input.substr(peg$currPos, 2) === peg$c88) {
                      s4 = peg$c88;
                      peg$currPos += 2;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c89); }
                    }
                    if (s4 === peg$FAILED) {
                      s4 = peg$currPos;
                      s5 = [];
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s4;
                        s5 = peg$c90();
                      }
                      s4 = s5;
                    }
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c93(s1, s4);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsegeneric_func();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = peg$currPos;
              s2 = peg$c94(s1);
              if (s2) {
                s2 = peg$c54;
              } else {
                s2 = peg$c0;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c95(s1);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsegeneric_func();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = peg$currPos;
                s2 = peg$c96(s1);
                if (s2) {
                  s2 = peg$c54;
                } else {
                  s2 = peg$c0;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parse_();
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c97(s1);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parsegeneric_func();
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = peg$currPos;
                  s2 = peg$c98(s1);
                  if (s2) {
                    s2 = peg$c54;
                  } else {
                    s2 = peg$c0;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parse_();
                    if (s3 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 123) {
                        s4 = peg$c77;
                        peg$currPos++;
                      } else {
                        s4 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c78); }
                      }
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsegeneric_func();
                        if (s5 !== peg$FAILED) {
                          peg$reportedPos = peg$currPos;
                          s6 = peg$c99(s1, s5);
                          if (s6) {
                            s6 = peg$c54;
                          } else {
                            s6 = peg$c0;
                          }
                          if (s6 !== peg$FAILED) {
                            s7 = peg$parse_();
                            if (s7 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 125) {
                                s8 = peg$c50;
                                peg$currPos++;
                              } else {
                                s8 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c51); }
                              }
                              if (s8 !== peg$FAILED) {
                                s9 = peg$parse_();
                                if (s9 !== peg$FAILED) {
                                  peg$reportedPos = s0;
                                  s1 = peg$c100(s1, s5);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$c0;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$c0;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c0;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parsegeneric_func();
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = peg$currPos;
                    s2 = peg$c101(s1);
                    if (s2) {
                      s2 = peg$c54;
                    } else {
                      s2 = peg$c0;
                    }
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parse_();
                      if (s3 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c102(s1);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 92) {
                      s1 = peg$c103;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c104); }
                    }
                    if (s1 !== peg$FAILED) {
                      if (peg$c105.test(input.charAt(peg$currPos))) {
                        s2 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s2 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c106); }
                      }
                      if (s2 !== peg$FAILED) {
                        s3 = peg$parse_();
                        if (s3 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c107(s2);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c0;
                    }
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (peg$c108.test(input.charAt(peg$currPos))) {
                        s1 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c109); }
                      }
                      if (s1 !== peg$FAILED) {
                        s2 = peg$parse_();
                        if (s2 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c82(s1);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c0;
                      }
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (peg$c110.test(input.charAt(peg$currPos))) {
                          s1 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c111); }
                        }
                        if (s1 !== peg$FAILED) {
                          s2 = peg$parse_();
                          if (s2 !== peg$FAILED) {
                            peg$reportedPos = s0;
                            s1 = peg$c112(s1);
                            s0 = s1;
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c0;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c0;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDELIMITER() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 33,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsedelimiter_uf_lt();
      if (s1 === peg$FAILED) {
        s1 = peg$parsedelimiter_uf_op();
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c86;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c82(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 92) {
          s1 = peg$c103;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c104); }
        }
        if (s1 !== peg$FAILED) {
          if (peg$c113.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c114); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c107(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsegeneric_func();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = peg$currPos;
            s2 = peg$c115(s1);
            if (s2) {
              s2 = peg$c54;
            } else {
              s2 = peg$c0;
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c95(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsegeneric_func();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = peg$currPos;
              s2 = peg$c116(s1);
              if (s2) {
                s2 = peg$c54;
              } else {
                s2 = peg$c0;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parse_();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c117(s1);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          }
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFUN_AR1nb() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 34,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c118(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFUN_AR1opt() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 81 + 35,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c120(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
              s4 = peg$c86;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c87); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c119(s1);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNEXT_CELL() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 36,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        s1 = peg$c121;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c122); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseNEXT_ROW() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 37,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c123) {
        s1 = peg$c123;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c124); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_MATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 38,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 14) === peg$c125) {
        s1 = peg$c125;
        peg$currPos += 14;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c126); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_MATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 39,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 12) === peg$c127) {
        s1 = peg$c127;
        peg$currPos += 12;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c128); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_PMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 40,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c129) {
        s1 = peg$c129;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c130); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_PMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 41,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c131) {
        s1 = peg$c131;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c132); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_BMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 42,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c133) {
        s1 = peg$c133;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c134); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_BMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 43,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c135) {
        s1 = peg$c135;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c136); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_BBMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 44,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c137) {
        s1 = peg$c137;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c138); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_BBMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 45,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c139) {
        s1 = peg$c139;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c140); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_VMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 46,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c141) {
        s1 = peg$c141;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c142); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_VMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 47,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c143) {
        s1 = peg$c143;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c144); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_VVMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 48,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c145) {
        s1 = peg$c145;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c146); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_VVMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 49,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c147) {
        s1 = peg$c147;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c148); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_ARRAY() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 50,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c149) {
        s1 = peg$c149;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c150); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_ARRAY() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 51,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 11) === peg$c151) {
        s1 = peg$c151;
        peg$currPos += 11;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c152); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_ALIGN() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 52,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c153) {
        s1 = peg$c153;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c154); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_ALIGN() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 53,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 11) === peg$c155) {
        s1 = peg$c155;
        peg$currPos += 11;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c156); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_ALIGNED() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 54,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c157) {
        s1 = peg$c157;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c158); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_ALIGNED() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 55,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c159) {
        s1 = peg$c159;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c160); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_ALIGNAT() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 56,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c161) {
        s1 = peg$c161;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c162); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_ALIGNAT() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 57,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c163) {
        s1 = peg$c163;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c164); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_ALIGNEDAT() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 58,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 17) === peg$c165) {
        s1 = peg$c165;
        peg$currPos += 17;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c166); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_ALIGNEDAT() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 59,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 15) === peg$c167) {
        s1 = peg$c167;
        peg$currPos += 15;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c168); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_SMALLMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 60,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 19) === peg$c169) {
        s1 = peg$c169;
        peg$currPos += 19;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c170); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_SMALLMATRIX() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 61,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 17) === peg$c171) {
        s1 = peg$c171;
        peg$currPos += 17;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c172); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBEGIN_CASES() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 62,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 13) === peg$c173) {
        s1 = peg$c173;
        peg$currPos += 13;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c174); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEND_CASES() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 63,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 11) === peg$c175) {
        s1 = peg$c175;
        peg$currPos += 11;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c176); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseSQ_CLOSE() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 64,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 93) {
        s1 = peg$c177;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c178); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCURLY_OPEN() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 65,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c77;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c78); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseCURLY_CLOSE() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 66,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 125) {
        s1 = peg$c50;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c51); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseSUP() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 67,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 94) {
        s1 = peg$c179;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c180); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseSUB() {
      var s0, s1, s2;

      var key    = peg$currPos * 81 + 68,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 95) {
        s1 = peg$c181;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c182); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsegeneric_func() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 69,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c103;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c104); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsealpha();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsealpha();
          }
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c183();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseBIG() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 70,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c184(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFUN_AR1() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 71,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c185(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsegeneric_func();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = peg$currPos;
          s2 = peg$c186(s1);
          if (s2) {
            s2 = peg$c54;
          } else {
            s2 = peg$c0;
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c186(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFUN_AR2() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 72,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c187(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFUN_INFIX() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 73,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c188(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseDECLh() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 74,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c189(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c190(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseFUN_AR2nb() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 75,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c191(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseLEFT() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 76,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c192(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseRIGHT() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 77,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c193(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseHLINE() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 81 + 78,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsegeneric_func();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = peg$currPos;
        s2 = peg$c194(s1);
        if (s2) {
          s2 = peg$c54;
        } else {
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseimpossible() {
      var s0;

      var key    = peg$currPos * 81 + 79,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      peg$reportedPos = peg$currPos;
      s0 = peg$c195();
      if (s0) {
        s0 = peg$c54;
      } else {
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseEOF() {
      var s0;

      var key    = peg$currPos * 81 + 80,
          cached = peg$cache[key];

      if (cached) {
        peg$currPos = cached.nextPos;
        return cached.result;
      }

      peg$reportedPos = peg$currPos;
      s0 = peg$c196();
      if (s0) {
        s0 = peg$c54;
      } else {
        s0 = peg$c0;
      }

      peg$cache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }


      var ast = require('./ast');

      var sq_close_ri = ast.RenderT.HTMLABLEC(ast.FontClass.UFH(), "]", "]");

      var lst2arr = function(l) {
        var arr = [];
        while (l !== null) {
          arr.push(l.head);
          l = l.tail;
        }
        return arr;
      };

      // track all known function names, so we can give good errors for unknown
      // functions.
      var all_functions = Object.create(null);
      all_functions['\\begin'] = all_functions['\\end'] = true;

      var arr2set = function(a) {
        // note that the fact that all keys in the set are prefixed with '\\'
        // helps avoid accidental name conflicts.  But use Object.create(null)
        // to be extra safe.
        var set = Object.create(null);
        a.forEach(function(v) { set[v] = all_functions[v] = true; });
        return set;
      };
      var obj2map = function(o) {
        // this just recreates the argument, but with `null` as prototype.
        var map = Object.create(null);
        Object.keys(o).forEach(function(f) {
          map[f] = o[f]; all_functions[f] = true;
        });
        return map;
      };

      // Sets of function names
      var box_functions = arr2set([
        "\\text", "\\mbox", "\\hbox", "\\vbox"
      ]);

      var latex_function_names = arr2set([
        "\\arccos", "\\arcsin", "\\arctan", "\\arg", "\\cosh", "\\cos",
        "\\cot", "\\coth", "\\csc", "\\deg", "\\det", "\\dim", "\\exp",
        "\\gcd", "\\hom", "\\inf", "\\ker", "\\lg", "\\lim", "\\liminf",
        "\\limsup", "\\ln", "\\log", "\\max", "\\min", "\\Pr", "\\sec",
        "\\sin", "\\sinh", "\\sup", "\\tan", "\\tanh"
      ]);

      var mediawiki_function_names = arr2set([
        "\\arccot", "\\arcsec", "\\arccsc", "\\sgn", "\\sen"
      ]);

      var other_literals1 = arr2set([
        "\\aleph",
        "\\alpha",
        "\\amalg",
        "\\And",
        "\\angle",
        "\\approx",
        "\\approxeq",
        "\\ast",
        "\\asymp",
        "\\backepsilon",
        "\\backprime",
        "\\backsim",
        "\\backsimeq",
        "\\barwedge",
        "\\Bbbk",
        "\\because",
        "\\beta",
        "\\beth",
        "\\between",
        "\\bigcap",
        "\\bigcirc",
        "\\bigcup",
        "\\bigodot",
        "\\bigoplus",
        "\\bigotimes",
        "\\bigsqcup",
        "\\bigstar",
        "\\bigtriangledown",
        "\\bigtriangleup",
        "\\biguplus",
        "\\bigvee",
        "\\bigwedge",
        "\\blacklozenge",
        "\\blacksquare",
        "\\blacktriangle",
        "\\blacktriangledown",
        "\\blacktriangleleft",
        "\\blacktriangleright",
        "\\bot",
        "\\bowtie",
        "\\Box",
        "\\boxdot",
        "\\boxminus",
        "\\boxplus",
        "\\boxtimes",
        "\\bullet",
        "\\bumpeq",
        "\\Bumpeq",
        "\\cap",
        "\\Cap",
        "\\cdot",
        "\\cdots",
        "\\centerdot",
        "\\checkmark",
        "\\chi",
        "\\circ",
        "\\circeq",
        "\\circlearrowleft",
        "\\circlearrowright",
        "\\circledast",
        "\\circledcirc",
        "\\circleddash",
        "\\circledS",
        "\\clubsuit",
        "\\colon",
        "\\color",
        "\\complement",
        "\\cong",
        "\\coprod",
        "\\cup",
        "\\Cup",
        "\\curlyeqprec",
        "\\curlyeqsucc",
        "\\curlyvee",
        "\\curlywedge",
        "\\curvearrowleft",
        "\\curvearrowright",
        "\\dagger",
        "\\daleth",
        "\\dashv",
        "\\ddagger",
        "\\ddots",
        "\\definecolor",
        "\\delta",
        "\\Delta",
        "\\diagdown",
        "\\diagup",
        "\\diamond",
        "\\Diamond",
        "\\diamondsuit",
        "\\digamma",
        "\\displaystyle",
        "\\div",
        "\\divideontimes",
        "\\doteq",
        "\\doteqdot",
        "\\dotplus",
        "\\dots",
        "\\dotsb",
        "\\dotsc",
        "\\dotsi",
        "\\dotsm",
        "\\dotso",
        "\\doublebarwedge",
        "\\downdownarrows",
        "\\downharpoonleft",
        "\\downharpoonright",
        "\\ell",
        "\\emptyset",
        "\\epsilon",
        "\\eqcirc",
        "\\eqsim",
        "\\eqslantgtr",
        "\\eqslantless",
        "\\equiv",
        "\\eta",
        "\\eth",
        "\\exists",
        "\\fallingdotseq",
        "\\Finv",
        "\\flat",
        "\\forall",
        "\\frown",
        "\\Game",
        "\\gamma",
        "\\Gamma",
        "\\geq",
        "\\geqq",
        "\\geqslant",
        "\\gets",
        "\\gg",
        "\\ggg",
        "\\gimel",
        "\\gnapprox",
        "\\gneq",
        "\\gneqq",
        "\\gnsim",
        "\\gtrapprox",
        "\\gtrdot",
        "\\gtreqless",
        "\\gtreqqless",
        "\\gtrless",
        "\\gtrsim",
        "\\gvertneqq",
        "\\hbar",
        "\\heartsuit",
        //"\\hline", // moved to hline_function
        "\\hookleftarrow",
        "\\hookrightarrow",
        "\\hslash",
        "\\iff",
        "\\iiiint",
        "\\iiint",
        "\\iint",
        "\\Im",
        "\\imath",
        "\\implies",
        "\\in",
        "\\infty",
        "\\injlim",
        "\\int",
        "\\intercal",
        "\\iota",
        "\\jmath",
        "\\kappa",
        "\\lambda",
        "\\Lambda",
        "\\land",
        "\\ldots",
        "\\leftarrow",
        "\\Leftarrow",
        "\\leftarrowtail",
        "\\leftharpoondown",
        "\\leftharpoonup",
        "\\leftleftarrows",
        "\\leftrightarrow",
        "\\Leftrightarrow",
        "\\leftrightarrows",
        "\\leftrightharpoons",
        "\\leftrightsquigarrow",
        "\\leftthreetimes",
        "\\leq",
        "\\leqq",
        "\\leqslant",
        "\\lessapprox",
        "\\lessdot",
        "\\lesseqgtr",
        "\\lesseqqgtr",
        "\\lessgtr",
        "\\lesssim",
        "\\limits",
        "\\ll",
        "\\Lleftarrow",
        "\\lll",
        "\\lnapprox",
        "\\lneq",
        "\\lneqq",
        "\\lnot",
        "\\lnsim",
        "\\longleftarrow",
        "\\Longleftarrow",
        "\\longleftrightarrow",
        "\\Longleftrightarrow",
        "\\longmapsto",
        "\\longrightarrow",
        "\\Longrightarrow",
        "\\looparrowleft",
        "\\looparrowright",
        "\\lor",
        "\\lozenge",
        "\\Lsh",
        "\\ltimes",
        "\\lVert",
        "\\lvertneqq",
        "\\mapsto",
        "\\measuredangle",
        "\\mho",
        "\\mid",
        "\\mod",
        "\\models",
        "\\mp",
        "\\mu",
        "\\multimap",
        "\\nabla",
        "\\natural",
        "\\ncong",
        "\\nearrow",
        "\\neg",
        "\\neq",
        "\\nexists",
        "\\ngeq",
        "\\ngeqq",
        "\\ngeqslant",
        "\\ngtr",
        "\\ni",
        "\\nleftarrow",
        "\\nLeftarrow",
        "\\nleftrightarrow",
        "\\nLeftrightarrow",
        "\\nleq",
        "\\nleqq",
        "\\nleqslant",
        "\\nless",
        "\\nmid",
        "\\nolimits",
        "\\not",
        "\\notin",
        "\\nparallel",
        "\\nprec",
        "\\npreceq",
        "\\nrightarrow",
        "\\nRightarrow",
        "\\nshortmid",
        "\\nshortparallel",
        "\\nsim",
        "\\nsubseteq",
        "\\nsubseteqq",
        "\\nsucc",
        "\\nsucceq",
        "\\nsupseteq",
        "\\nsupseteqq",
        "\\ntriangleleft",
        "\\ntrianglelefteq",
        "\\ntriangleright",
        "\\ntrianglerighteq",
        "\\nu",
        "\\nvdash",
        "\\nVdash",
        "\\nvDash",
        "\\nVDash",
        "\\nwarrow",
        "\\odot",
        "\\oint",
        "\\omega",
        "\\Omega",
        "\\ominus",
        "\\oplus",
        "\\oslash",
        "\\otimes",
        //"\\overbrace", // moved to ar1nb (grabs trailing sub/superscript)
        "\\P",
        "\\pagecolor",
        "\\parallel",
        "\\partial",
        "\\perp",
        "\\phi",
        "\\Phi",
        "\\pi",
        "\\Pi",
        "\\pitchfork",
        "\\pm",
        "\\prec",
        "\\precapprox",
        "\\preccurlyeq",
        "\\preceq",
        "\\precnapprox",
        "\\precneqq",
        "\\precnsim",
        "\\precsim",
        "\\prime",
        "\\prod",
        "\\projlim",
        "\\propto",
        "\\psi",
        "\\Psi",
        "\\qquad",
        "\\quad",
        "\\Re",
        "\\rho",
        "\\rightarrow",
        "\\Rightarrow",
        "\\rightarrowtail",
        "\\rightharpoondown",
        "\\rightharpoonup",
        "\\rightleftarrows",
        "\\rightrightarrows",
        "\\rightsquigarrow",
        "\\rightthreetimes",
        "\\risingdotseq",
        "\\Rrightarrow",
        "\\Rsh",
        "\\rtimes",
        "\\rVert",
        "\\S",
        "\\scriptscriptstyle",
        "\\scriptstyle",
        "\\searrow",
        "\\setminus",
        "\\sharp",
        "\\shortmid",
        "\\shortparallel",
        "\\sigma",
        "\\Sigma",
        "\\sim",
        "\\simeq",
        "\\smallfrown",
        "\\smallsetminus",
        "\\smallsmile",
        "\\smile",
        "\\spadesuit",
        "\\sphericalangle",
        "\\sqcap",
        "\\sqcup",
        "\\sqsubset",
        "\\sqsubseteq",
        "\\sqsupset",
        "\\sqsupseteq",
        "\\square",
        "\\star",
        "\\subset",
        "\\Subset",
        "\\subseteq",
        "\\subseteqq",
        "\\subsetneq",
        "\\subsetneqq",
        "\\succ",
        "\\succapprox",
        "\\succcurlyeq",
        "\\succeq",
        "\\succnapprox",
        "\\succneqq",
        "\\succnsim",
        "\\succsim",
        "\\sum",
        "\\supset",
        "\\Supset",
        "\\supseteq",
        "\\supseteqq",
        "\\supsetneq",
        "\\supsetneqq",
        "\\surd",
        "\\swarrow",
        "\\tau",
        "\\textstyle",
        "\\therefore",
        "\\theta",
        "\\Theta",
        "\\thickapprox",
        "\\thicksim",
        "\\times",
        "\\to",
        "\\top",
        "\\triangle",
        "\\triangledown",
        "\\triangleleft",
        "\\trianglelefteq",
        "\\triangleq",
        "\\triangleright",
        "\\trianglerighteq",
        //"\\underbrace", // moved to ar1nb (grabs trailing sub/superscript)
        "\\upharpoonleft",
        "\\upharpoonright",
        "\\uplus",
        "\\upsilon",
        "\\Upsilon",
        "\\upuparrows",
        "\\varepsilon",
        "\\varinjlim",
        "\\varkappa",
        "\\varliminf",
        "\\varlimsup",
        "\\varnothing",
        "\\varphi",
        "\\varpi",
        "\\varprojlim",
        "\\varpropto",
        "\\varrho",
        "\\varsigma",
        "\\varsubsetneq",
        "\\varsubsetneqq",
        "\\varsupsetneq",
        "\\varsupsetneqq",
        "\\vartheta",
        "\\vartriangle",
        "\\vartriangleleft",
        "\\vartriangleright",
        "\\vdash",
        "\\Vdash",
        "\\vDash",
        "\\vdots",
        "\\vee",
        "\\veebar",
        "\\vline",
        "\\Vvdash",
        "\\wedge",
        "\\wp",
        "\\wr",
        "\\xi",
        "\\Xi",
        "\\zeta"
      ]);

      // text-mode literals; enclose in \mbox
      var other_literals2 = arr2set([
        "\\AA",
        "\\Coppa",
        "\\coppa",
        "\\Digamma",
        "\\euro",
        "\\geneuro",
        "\\geneuronarrow",
        "\\geneurowide",
        "\\Koppa",
        "\\koppa",
        "\\officialeuro",
        "\\Sampi",
        "\\sampi",
        "\\Stigma",
        "\\stigma",
        "\\textvisiblespace",
        "\\varstigma"
      ]);

      var other_literals3 = obj2map({
        "\\C": "\\mathbb {C}",
        "\\H": "\\mathbb {H}",
        "\\N": "\\mathbb {N}",
        "\\Q": "\\mathbb {Q}",
        "\\R": "\\mathbb {R}",
        "\\Z": "\\mathbb {Z}",
        "\\alef": "\\aleph",
        "\\alefsym": "\\aleph",
        "\\Alpha": "\\mathrm {A}",
        "\\and": "\\land",
        "\\ang": "\\angle",
        "\\Beta": "\\mathrm {B}",
        "\\bull": "\\bullet",
        "\\Chi": "\\mathrm {X}",
        "\\clubs": "\\clubsuit",
        "\\cnums": "\\mathbb {C}",
        "\\Complex": "\\mathbb {C}",
        "\\Dagger": "\\ddagger",
        "\\diamonds": "\\diamondsuit",
        "\\Doteq": "\\doteqdot",
        "\\doublecap": "\\Cap",
        "\\doublecup": "\\Cup",
        "\\empty": "\\emptyset",
        "\\Epsilon": "\\mathrm {E}",
        "\\Eta": "\\mathrm {H}",
        "\\exist": "\\exists",
        "\\ge": "\\geq",
        "\\gggtr": "\\ggg",
        "\\hAar": "\\Leftrightarrow",
        "\\harr": "\\leftrightarrow",
        "\\Harr": "\\Leftrightarrow",
        "\\hearts": "\\heartsuit",
        "\\image": "\\Im",
        "\\infin": "\\infty",
        "\\Iota": "\\mathrm {I}",
        "\\isin": "\\in",
        "\\Kappa": "\\mathrm {K}",
        "\\larr": "\\leftarrow",
        "\\Larr": "\\Leftarrow",
        "\\lArr": "\\Leftarrow",
        "\\le": "\\leq",
        "\\lrarr": "\\leftrightarrow",
        "\\Lrarr": "\\Leftrightarrow",
        "\\lrArr": "\\Leftrightarrow",
        "\\Mu": "\\mathrm {M}",
        "\\natnums": "\\mathbb {N}",
        "\\ne": "\\neq",
        "\\Nu": "\\mathrm {N}",
        "\\O": "\\emptyset",
        "\\omicron": "\\mathrm {o}",
        "\\Omicron": "\\mathrm {O}",
        "\\or": "\\lor",
        "\\part": "\\partial",
        "\\plusmn": "\\pm",
        "\\rarr": "\\rightarrow",
        "\\Rarr": "\\Rightarrow",
        "\\rArr": "\\Rightarrow",
        "\\real": "\\Re",
        "\\reals": "\\mathbb {R}",
        "\\Reals": "\\mathbb {R}",
        "\\restriction": "\\upharpoonright",
        "\\Rho": "\\mathrm {P}",
        "\\sdot": "\\cdot",
        "\\sect": "\\S",
        "\\spades": "\\spadesuit",
        "\\sub": "\\subset",
        "\\sube": "\\subseteq",
        "\\supe": "\\supseteq",
        "\\Tau": "\\mathrm {T}",
        "\\thetasym": "\\vartheta",
        "\\varcoppa": "\\mbox{\\coppa}",
        "\\weierp": "\\wp",
        "\\Zeta": "\\mathrm {Z}"
      });

      var big_literals = arr2set([
        "\\big",
        "\\Big",
        "\\bigg",
        "\\Bigg",
        "\\biggl",
        "\\Biggl",
        "\\biggr",
        "\\Biggr",
        "\\bigl",
        "\\Bigl",
        "\\bigr",
        "\\Bigr"
      ]);

      var other_delimiters1 = arr2set([
        "\\backslash",
        "\\downarrow",
        "\\Downarrow",
        "\\langle",
        "\\lbrace",
        "\\lceil",
        "\\lfloor",
        "\\llcorner",
        "\\lrcorner",
        "\\rangle",
        "\\rbrace",
        "\\rceil",
        "\\rfloor",
        "\\rightleftharpoons",
        "\\twoheadleftarrow",
        "\\twoheadrightarrow",
        "\\ulcorner",
        "\\uparrow",
        "\\Uparrow",
        "\\updownarrow",
        "\\Updownarrow",
        "\\urcorner",
        "\\Vert",
        "\\vert",
        "\\lbrack",
        "\\rbrack"
      ]);

      var other_delimiters2 = obj2map({
        "\\darr": "\\downarrow",
        "\\dArr": "\\Downarrow",
        "\\Darr": "\\Downarrow",
        "\\lang": "\\langle",
        "\\rang": "\\rangle",
        "\\uarr": "\\uparrow",
        "\\uArr": "\\Uparrow",
        "\\Uarr": "\\Uparrow"
      });

      var fun_ar1 = arr2set([
        "\\acute",
        "\\bar",
        "\\bcancel",
        "\\bmod",
        "\\boldsymbol",
        "\\breve",
        "\\cancel",
        "\\check",
        "\\ddot",
        "\\dot",
        "\\emph",
        "\\grave",
        "\\hat",
        //"\\mathbb", // moved to fun_ar1nb
        //"\\mathbf", // moved to fun_ar1nb
        "\\mathbin",
        "\\mathcal",
        "\\mathclose",
        "\\mathfrak",
        "\\mathit",
        "\\mathop",
        "\\mathopen",
        "\\mathord",
        "\\mathpunct",
        "\\mathrel",
        //"\\mathrm", // moved to fun_ar1nb
        "\\mathsf",
        "\\mathtt",
        //"\\operatorname", // already exists in fun_ar1nb
        "\\overleftarrow",
        "\\overleftrightarrow",
        "\\overline",
        "\\overrightarrow",
        "\\pmod",
        "\\sqrt",
        "\\textbf",
        "\\textit",
        "\\textrm",
        "\\textsf",
        "\\texttt",
        "\\tilde",
        "\\underline",
        "\\vec",
        "\\widehat",
        "\\widetilde",
        "\\xcancel",
        "\\xleftarrow",
        "\\xrightarrow"
      ]);

      var other_fun_ar1 = obj2map({
        "\\Bbb": "\\mathbb",
        "\\bold": "\\mathbf"
      });

      var fun_ar1nb = arr2set([
        "\\operatorname",
        "\\overbrace",
        "\\mathbb",
        "\\mathbf",
        "\\mathrm",
        "\\underbrace"
      ]);

      var fun_ar1opt = arr2set([
        "\\sqrt", "\\xleftarrow", "\\xrightarrow"
      ]);

      var fun_ar2 = arr2set([
        "\\binom",
        "\\cancelto",
        "\\cfrac",
        "\\dbinom",
        "\\dfrac",
        "\\frac",
        "\\overset",
        "\\stackrel",
        "\\tbinom",
        "\\tfrac",
        "\\underset"
      ]);

      var fun_ar2nb = arr2set([
        "\\sideset"
      ]);

      var fun_infix = arr2set([
        "\\atop",
        "\\choose",
        "\\over"
      ]);

      var declh_function = arr2set([
        "\\rm",
        "\\it",
        "\\cal",
        "\\bf"
      ]);

      var left_function = arr2set([ "\\left" ]);
      var right_function = arr2set([ "\\right" ]);
      var hline_function = arr2set([ "\\hline" ]);

      var context = {};


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();